//  Sass List-Maps 1.0.0
//  a libsass polyfill for rubysass "maps" data-type -- using lists
//  by @lunelson
//  MIT License

//
//                        88  88  88           88
//                 ,d     ""  88  ""    ,d     ""
//                 88         88        88
//  88       88  MM88MMM  88  88  88  MM88MMM  88   ,adPPYba,  ,adPPYba,
//  88       88    88     88  88  88    88     88  a8P_____88  I8[    ""
//  88       88    88     88  88  88    88     88  8PP"""""""   `"Y8ba,
//  "8a,   ,a88    88,    88  88  88    88,    88  "8b,   ,aa  aa    ]8I
//   `"YbbdP'Y8    "Y888  88  88  88    "Y888  88   `"Ybbd8"'  `"YbbdP"'
//


//////////////////
// list-slice() //
//////////////////

/**
 * Return a sub-list from `$list`, sliced from `$start` to `$end` indexes.
 *
 * @since 1.0.0 - renamed to 'list-slice', aliased to 'slice'
 *
 * @param {List}   $list                  - list to slice
 * @param {Number} $start (1)             - start index
 * @param {Number} $end   (length($list)) - end index
 * @param {String} $sep   ('comma')       - default list separator
 *
 * @return {List}
 *
 * @example scss
 * .test {
 *   out: list-slice(a b c d e, 2, 4); // b c d
 * }
 */
@function list-slice($list, $start: 1, $end: length($list), $sep: 'comma') {

  $output: ();

  @for $i from $start through $end {
    $output: append($output, nth($list, $i), $sep);
  }

  @return $output;
}

/**
 * @alias list-slice
 *
 * @since 1.0.0
 */
@function slice($args...) { @return list-slice($args...); }

////////////////////
// list-set-nth() //
////////////////////

/**
 * Return `$list` with value at `$index` set/updated to `$value`.
 *
 * @since 1.0.0 - renamed to 'list-set-nth', aliased to 'set-nth'
 *
 * @param {List}   $list            - list to set
 * @param {Number} $index           - index to set
 * @param {*}      $value           - new value
 * @param {String} $sep   ('comma') - list separator
 *
 * @return {List}
 *
 * @example scss
 * .test {
 *   out: list-set-nth(a b c d e, 2, z);
 * }
 * @example css
 * .test {
 *   out: a z c d e;
 * }
 */
@function list-set-nth($list, $index, $value, $sep: 'comma') {

  $length: length($list);
  $output: ();

  @if $index > $length or $index <= 0 {
    @return $list;
  }

  @if $index > 1 {
    @for $i from 1 through $index - 1 {
      $output: append($output, nth($list, $i), $sep);
    }
  }

  $output: append($output, $value, $sep);

  @if $length > 1 {
    @for $i from $index + 1 through $length {
      $output: append($output, nth($list, $i), $sep);
    }
  }

  @return $output;
}

/**
 * @alias list-set-nth
 *
 * @since 1.0.0
 */
@function set-nth($args...) { @return list-set-nth($args...); }

/////////////////
// tuple-key() //
/////////////////

/**
 * Return the key (first item) from a `$tuple` (pair).
 *
 * @param {List} $tuple - a pair (list of length 2), to extract key from
 *
 * @return {*}
 */
@function tuple-key($tuple) {

  @if length($tuple) < 1 {
    @return null;
  }

  @return nth($tuple, 1);
}

/**
 * @alias tuple-key
 *
 * @since 0.9.3
 */
@function key($tuple) { @return tuple-key($tuple); }

///////////////////
// tuple-value() //
///////////////////

/**
 * Return the value (second item) from a `$tuple` (pair).
 *
 * @param {List} $tuple - a pair (list of length 2), to extract value from
 *
 * @return {*}
 */
@function tuple-value($tuple) {

  @if length($tuple) < 2 {
    @return null;
  }

  @return nth($tuple, 2);
}

/**
 * @alias tuple-value
 *
 * @since 0.9.3
 */
@function value($tuple) { @return tuple-value($tuple); }

/**
 * Returns a valid list-map from `$list`, ensuring it is a list-of-lists.
 *
 * @since 0.9.5
 *
 * @access private
 *
 * @param {List} $list - list-map to check
 *
 * @return {List}
 */
@function list-map-check($list) {

  @if length($list) == 2 and length(nth($list, 1)) == 1 {
    @return append((), $list, 'comma');
  }

  @return $list;
}

//
//   ,adPPYba,   ,adPPYba,   8b,dPPYba,   ,adPPYba,
//  a8"     ""  a8"     "8a  88P'   "Y8  a8P_____88
//  8b          8b       d8  88          8PP"""""""
//  "8a,   ,aa  "8a,   ,a8"  88          "8b,   ,aa
//   `"Ybbd8"'   `"YbbdP"'   88           `"Ybbd8"'
//

////////////////
// map-keys() //
////////////////

/**
 * Return comma-separated list of keys from map.
 * (Conformant with ruby-sass `map-keys()` function)
 *
 * @since 0.9.5 - uses `list-map-check()` to handle single pairs
 *
 * @param {ArgList} $list - list to retrieve keys from
 *
 * @requires {function} list-map-check
 * @requires {function} tuple-key
 *
 * @return {List}
 */
@function map-keys($list...) {
  $list: if(length($list) == 1, list-map-check($list...), list-map-check($list));
  $output: ();

  @each $tuple in $list {
    $output: append($output, tuple-key($tuple), 'comma');
  }

  @return $output;
}

/**
 * @alias map-keys
 *
 * @since 1.0.0
 */
@function keys($list...) {

  @return map-keys($list...);
}

//////////////////
// map-values() //
//////////////////

/**
 * Return comma-separated list of values from map.
 * (Conformant with ruby-sass `map-values()` function)
 *
 * @since 0.9.5 - uses `list-map-check()` to handle single pairs
 *
 * @param {ArgList} $list - list to retrieve values from
 *
 * @requires {function} list-map-check
 * @requires {function} tuple-value
 *
 * @return {List}
 */
@function map-values($list...) {
  $list: if(length($list) == 1, list-map-check($list...), list-map-check($list));
  $output: ();

  @each $tuple in $list {
    $output: append($output, tuple-value($tuple), 'comma');
  }

  @return $output;
}

/**
 * @alias map-values
 *
 * @since 1.0.0
 */
@function values($list...) {

  @return map-values($list...);
}

///////////////////
// map-has-key() //
///////////////////

/**
 * Check whether `$key` exists in `$list` at root level.
 * (Conformant with ruby-sass `map-has-key()` function).
 *
 * @param {List} $list - list to check
 * @param {*}    $key  - key to check in list
 *
 * @requires {function} list-map-check
 * @requires {function} tuple-key
 *
 * @return {Bool}
 */
@function map-has-key($list, $key) {

  $list: list-map-check($list);

  @each $tuple in $list {

    @if tuple-key($tuple) == $key {
      @return true;
    }
  }

  @return false;
}

/**
 * @alias map-has-key
 *
 * @since 1.0.0
 */
@function has-key($list, $key) {

  @return map-has-key($list, $key);
}

////////////////////////////////////////////////////////////
// list-map versions of map-get(), -merge() and -remove() //
////////////////////////////////////////////////////////////

/**
 * Return value corresponding to `$key` in `$list`.
 * Conformant with rubysass `map-get`.
 *
 * @since 0.9.5 - uses `list-map-check()` to handle single pairs automatically
 *
 * @param {List} $list         - map
 * @param {*}    $key          - key by which to look up value
 * @param {Bool} $check (true) - whether or not to check the map format first
 *
 * @requires {function} tuple-key
 * @requires {function} tuple-value
 * @requires {function} list-map-check
 *
 * @return {*}
 */
@function map-get($list, $key, $check: true) {
  @if $check {
    $list: list-map-check($list);
  }

  @each $tuple in $list {
    @if tuple-key($tuple) == $key {
      @return list-map-check(tuple-value($tuple));
    }
  }

  @return null;
}

/**
 * Return a merge of second map in to first map.
 * Conformant with rubysass `map-merge`.
 *
 * @since 0.9.5 - use `list-map-check` to handle single pairs automatically; `$check` parameter for internal use
 *
 * @param {List} $list1        - first map
 * @param {List} $list2        - second map
 * @param {Bool} $check (true) - whether or not to check the map first
 *
 * @requires {function} tuple-key
 * @requires {function} list-map-check
 * @requires {function} map-keys
 * @requires {function} set-nth
 *
 * @return {List}
 */
@function map-merge($list1, $list2, $check: true) {

  @if $check {
    $list1: list-map-check($list1);
    $list2: list-map-check($list2);
  }

  $keys1: map-keys($list1);

  @each $tuple in $list2 {

    $index: index($keys1, tuple-key($tuple));

    @if $index { $list1: list-set-nth($list1, $index, $tuple); }
    @else { $list1: append($list1, $tuple, 'comma'); }

  }

  @return $list1;
}

/**
 * Return map with tuples removed, according to `$keys` (if found).
 * Conformant with rubysass 3.4 `map-remove()`.
 *
 * @param {List} $list - map
 * @param {*}    $key  - key
 *
 * @requires {function} list-map-check
 *
 * @return {List}
 */
@function map-remove($list, $keys...) {

  $list: list-map-check($list);
  $output: ();

  @each $tuple in $list {
    @if index($keys, tuple-key($tuple)) == false {
      $output: append($output, $tuple, 'comma');
    }
  }

  @return $output;
}

//
//                       88                                                                         88
//                       88                                                                         88
//                       88                                                                         88
//  ,adPPYYba,   ,adPPYb,88  8b       d8  ,adPPYYba,  8b,dPPYba,    ,adPPYba,   ,adPPYba,   ,adPPYb,88
//  ""     `Y8  a8"    `Y88  `8b     d8'  ""     `Y8  88P'   `"8a  a8"     ""  a8P_____88  a8"    `Y88
//  ,adPPPPP88  8b       88   `8b   d8'   ,adPPPPP88  88       88  8b          8PP"""""""  8b       88
//  88,    ,88  "8a,   ,d88    `8b,d8'    88,    ,88  88       88  "8a,   ,aa  "8b,   ,aa  "8a,   ,d88
//  `"8bbdP"Y8   `"8bbdP"Y8      "8"      `"8bbdP"Y8  88       88   `"Ybbd8"'   `"Ybbd8"'   `"8bbdP"Y8
//

//////////////////////////////////////////////////////////////
// deep/nested map functions: map-get-z() and map-merge-z() //
//////////////////////////////////////////////////////////////

/**
 * A *deep* nested or chained version of `map-get`.
 *
 * @since 0.9.5 - now uses `list-map-check` to handle single pairs automatically
 * @since 0.9.2 - aliased as `get`; can replace `map-get` and `map-get-z` in usage
 *
 * @param {List}    $list - map
 * @param {ArgList} $keys - nested / chained key list (where to get value)
 *
 * @requires {function} map-get
 *
 * @return {*}
 */
@function map-get-z($list, $keys...) {

  @if $list == null {
    @return $list;
  }

  $length: length($keys);
  $list: map-get($list, nth($keys, 1));

  @if $length > 1 {

    @for $n from 2 through $length {

      @if $list == null {
        @return $list;
      }

      $list: map-get($list, nth($keys, $n), false);
    }

    @return $list;
  }

  @return $list;
}

/**
 * @alias map-get-z
 */
@function get($args...) {
  @return map-get-z($args...);
}

/**
 * A *deep* nested or chained version of `map-merge()`. Offers `map-set` syntax too.
 *
 * @since 0.9.5 - now uses `list-map-check` to handle single pairs automatically
 * @since 0.9.2 - aliased as `merge` and `set`; can replace `map-merge` and `map-merge-z` in usage
 *
 * @param {List}    $list            - map
 * @param {ArgList} $keys-and-values - nested / chained key list (where to merge value); final item in list is the value to be merged
 *
 * @requires {function} list-map-check
 * @requires {function} map-merge
 * @requires {function} map-get-z
 * @requires {function} slice
 *
 * @return {List}
 */
@function map-merge-z($list, $keys-and-value...) {

  $arg-length: length($keys-and-value);
  $value: nth($keys-and-value, $arg-length);
  $key-length: $arg-length - 1;
  $list: list-map-check($list);

  @if $key-length == 0 {
    $value: if(type-of($value) == 'list', map-merge($list, list-map-check($value), false), map-merge($list, append((), $value (), 'comma'), false));
  }

  @else {

    $start: 1;

    @if type-of($value) == 'list' {
      $start: 0;
      $value: list-map-check($value);
    }

    @for $i from $start through $key-length {

      $new-list: (); $old-list: ();

      @if $i == 0 { $new-list: $value; }
      @else { $new-list: append((), nth($keys-and-value, $key-length + 1 - $i) $value, 'comma'); }

      @if $i == $key-length { $old-list: $list; }
      @else { $old-list: map-get-z($list, list-slice($keys-and-value, 1, $key-length - $i)...) or (); }

      $value: map-merge($old-list, $new-list);
    }
  }

  @return $value;
}

/**
 * @alias map-merge-z
 */
@function merge($args...) {
  @return map-merge-z($args...);
}

/**
 * @alias map-merge-z
 */
@function set($args...) {
  @return map-merge-z($args...);
}

//
//                             ,d
//                             88
//   ,adPPYba,  8b,     ,d8  MM88MMM  8b,dPPYba,  ,adPPYYba,  ,adPPYba,
//  a8P_____88   `Y8, ,8P'     88     88P'   "Y8  ""     `Y8  I8[    ""
//  8PP"""""""     )888(       88     88          ,adPPPPP88   `"Y8ba,
//  "8b,   ,aa   ,d8" "8b,     88,    88          88,    ,88  aa    ]8I
//   `"Ybbd8"'  8P'     `Y8    "Y888  88          `"8bbdP"Y8  `"YbbdP"'
//

////////////////////
// map-prev-key() //
////////////////////

/**
 * Return previous key from map.
 *
 * @since 0.9.5
 *
 * @param {List} $list - map
 * @param {*}    $key  - pivot key
 *
 * @requires {function} map-keys
 * @requires {function} list-map-check
 *
 * @return {*}
 */
@function map-prev-key($list, $key) {
  $list: list-map-check($list);
  $keys: map-keys($list);

  @return nth($keys, index($keys, $key) - 1);
}

////////////////////
// map-next-key() //
////////////////////

/**
 * Return next key from map.
 *
 * @since 0.9.5
 *
 * @param {List} $list - map
 * @param {*}    $key  - pivot key
 *
 * @requires {function} map-keys
 * @requires {function} list-map-check
 *
 * @return {*}
 */
@function map-next-key($list, $key) {
  $list: list-map-check($list);
  $keys: map-keys($list);

  @return nth($keys, index($keys, $key) + 1);
}

// map-inspect()
/**
 * Return the string representation of a map.
 *
 * @since 0.9.5
 *
 * @param {ArgList} $list - map
 *
 * @requires {function} map-keys
 * @requires {function} list-map-check
 * @requires {function} tuple-key
 * @requires {function} tuple-value
 * @requires {function} map-inspect
 *
 * @return {String}
 */
@function map-inspect($list...) {

  $list: if(length($list) == 1, list-map-check($list...), list-map-check($list));
  $output: '(';
  $i: 1;

  @each $tuple in $list {

    @if length($tuple) != 2 {
      $output: $output + '#{$tuple}';
    }

    @else {
      $key: tuple-key($tuple);
      $value: tuple-value($tuple);
      $output: $output + '#{$key} ' + if(type-of($value) == 'list', '#{map-inspect($value)}', '#{$value}');
    }

    @if $i < length(map-keys($list)) {
      $output: $output + ', ';
    }

    $i: $i + 1;
  }

  @return $output + ')';
}

//////////////////
// map-pretty() //
//////////////////

/**
 * Return the string representation of a map with indents and line breaks.
 *
 * @since 0.9.9
 *
 * @param {List}   $list      - map
 * @param {Number} $level (1) - internal variable, do not touch
 *
 * @requires {function} map-keys
 * @requires {function} tuple-key
 * @requires {function} tuple-value
 * @requires {function} list-map-check
 * @requires {function} map-pretty
 *
 * @return {String}
 */
@function map-pretty($list, $level: 1) {
  $tab: '  ';
  $cr: '
';

  $list: if(length($list) == 1, list-map-check($list...), list-map-check($list));
  $indent: $tab; $outdent: $tab;

  @for $n from 1 through $level { $indent: $indent + $tab; }
  @for $n from 1 through $level - 1 { $outdent: $outdent + $tab; }

  $output: '(' + $cr + $indent;
  $i: 1;

  @each $tuple in $list {

    @if length($tuple) != 2 {
      $output: $output + '#{$tuple}';
    }

    @else {
      $key: nth($tuple, 1); $value: nth($tuple, 2);
      @if type-of($value) == 'list' { $output: $output + '#{$key} #{map-pretty($value, $level+1)}'; }
      @else { $output: $output + '#{$key} #{$value}'; }
    }

    @if $i < length(map-keys($list)) { $output: $output + ',' + $cr + $indent; }
    $i: $i + 1;
  }

  @return $output + $cr + $outdent + ')';
}

/**
 * @alias map-pretty
 */
@function map-inspect-pretty($list...) {
  @return map-pretty($list...);
}

/**
 * @alias map-pretty
 */
@function map-inspect-p($list...) {
  @return map-pretty($list...);
}

////////////////
// map-sort() //
////////////////

/**
 * Global sort dir variable.
 *
 * @type String
 */
$list-map-sort-dir: 'asc';

/**
 * Return sorted list-map, based on values at given key in given list-map.
 *
 * @param {List}    $list-map
 * @param {ArgList} $keys
 *
 * @requires {function} map-get-z
 * @requires {function} list-map-check
 * @requires {function} map-sort
 *
 * @return {List}
 */
@function map-sort($list-map, $keys...) {
  @if length($keys) < 1 {
    @return $list-map;
  }

  $list-map: list-map-check($list-map);

  @if length($list-map) > 1 {
    $less: (); $equal: (); $greater: ();
    $seed: nth($list-map, ceil(length($list-map) / 2));
    @each $item in $list-map {
      $item-value: map-get-z(nth($item, 2), $keys...);
      $seed-value: map-get-z(nth($seed, 2), $keys...);
      @if $list-map-sort-dir == 'asc' {
        @if $item-value == $seed-value { $equal: append($equal, $item, 'comma'); }
        @else if $item-value < $seed-value { $less: append($less, $item, 'comma'); }
        @else { $greater: append($greater, $item, 'comma'); }
      }
      @else {
        @if $item-value == $seed-value { $equal: append($equal, $item, 'comma'); }
        @else if $item-value > $seed-value { $less: append($less, $item, 'comma'); }
        @else { $greater: append($greater, $item, 'comma'); }
      }
    }
    @return join(join(map-sort($less, $keys...), $equal), map-sort($greater, $keys...));
  }

  @return $list-map;
}

////////////////
// map-json() //
////////////////

/**
 * Return JSON string representation of a map
 *
 * @since 1.0.0
 *
 * @param {ArgList} $list
 *
 * @requires {function} list-map-check
 * @requires {function} map-keys
 *
 * @return {String}
 */
@function map-json($list...) {

  $list: if(length($list) == 1, list-map-check($list...), list-map-check($list));
  $output: '{ '; $i: 1;

  @each $tuple in $list {

    @if length($tuple) != 2 {
      $output: $output + '#{$tuple}';
    }

    @else {

      $key: nth($tuple, 1);
      $value: nth($tuple, 2);

      @if type-of($value) == 'list' {
        $output: $output + '"#{$key}": #{map-json($value)}';
      }

      @else if type-of($value) == 'number' {
        $value: if(unitless($value), $value, '"#{$value}"');
        $output: $output + '"#{$key}": #{$value}';
      }

      @else {
        $value: if(type-of($value) == 'bool', $value, '"#{$value}"');
        $output: $output + '"#{$key}": #{$value}';
      }
    }

    @if $i < length(map-keys($list)) {
      $output: $output + ', ';
    }

    $i: $i + 1;
  }

  @return $output + ' }';
}
